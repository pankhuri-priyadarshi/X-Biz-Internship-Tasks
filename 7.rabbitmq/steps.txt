------------------ RabbitMQ Practice ----------------  13/10/25

** How to Run below files **
   -> docker run -d --name rabbitmq-server -p 5672:5672 -p 15672:15672 rabbitmq:3-management
     Then access it via browser at http://localhost:15672 (default guest/guest) or 
     click on the port created on docker container and after guest login we can see the rabbitmq dashboard.

   -> On 2 different terminal--run
      python sender.py
      pthon receiver.py

1.RabbitMQ – Basic Sender & Receiver (basic-send_receive_data)

    Learned how RabbitMQ connects two apps using queues.
    Created sender.py (producer) to send messages.
    Created receiver.py (consumer) to receive and print messages.
    Used channel.queue_declare() to create a queue.
    Sent messages with basic_publish() and received using basic_consume().
    Verified communication between both apps successfully.
    Status: Basic sender–receiver communication working correctly. 

2.RabbitMQ – Work Queue (work_queue)

    Understood how multiple workers share tasks equally.
    Used one producer and two consumers (workers).
    Implemented basic_qos(prefetch_count=1) for fair dispatch (1 task per worker).
    Added manual ACK (basic_ack) for reliability.
    Tested scenario where one worker crashes before ACK — message was requeued.
    Status: Work queue pattern successfully tested with multiple workers.

3.RabbitMQ – Fanout (Publish/Subscribe)-- (fanout)

    Learned about Fanout Exchange for broadcasting messages.
    Created one producer that sends messages to a fanout exchange.
    Created two consumers (consumer_email.py, consumer_logg.py).
    Each consumer received the same broadcast message simultaneously.
    Understood difference between Work Queue (one message → one worker) and Fanout (one message → all subscribers).
    Tested temporary and durable queue behavior in dashboard.
    Status: Fanout publish–subscribe model implemented and verified. 

4.RabbitMQ – Acknowledgment (ACK)

    Learned how ACK confirms message processing.
    Implemented auto_ack=False for manual confirmation using basic_ack().
    Verified that messages requeued automatically if consumer crashed before ACK.
    Understood that auto_ack=True can cause message loss.
    Observed message states in RabbitMQ UI (Ready / Unacked).
    Status: ACK mechanism tested and understood clearly.

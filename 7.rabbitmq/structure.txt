-------------------- RabbitMQ â€” Summary ------------------------------

1.RabbitMQ is an open-source message broker â€” it allows different applications or services to communicate asynchronously by sending messages.
2.It works using Producer â†’ Queue â†’ Consumer model.
    Producer: Sends messages
    Queue: Stores messages temporarily
    Consumer: Receives messages

3.RabbitMQ supports multiple exchange types to decide how messages are routed to queues:
    Direct Exchange: Sends message to a specific queue using a key.
    Fanout Exchange: Broadcasts message to all queues.
    Topic Exchange: Sends based on pattern-matching routing keys.
    Headers Exchange: Uses message headers instead of routing keys.

4.Brokerâ€™s job: Ensure messages are safely stored and delivered even if consumers are busy or offline.

5.Protocols: Uses AMQP (Advanced Message Queuing Protocol).
6.Use cases:
    Background task processing
    Communication between microservices
    Queue-based systems (like order processing or notifications)

7.Basic Commands / Concepts:
        queue_declare() â†’ Create a queue
        basic_publish() â†’ Send message
        basic_consume() â†’ Receive messages

8.In short: RabbitMQ = â€œPost office between servicesâ€ â€” ensures reliable message delivery.


------------------ACK (Acknowledgement) â€” Summary ---------------------

1.ACK (Acknowledgement) confirms that a message was successfully received and processed by the consumer.
2.Without ACK, RabbitMQ might delete messages even if the consumer crashed before processing â€” leading to data loss.
3.When ACK is enabled, RabbitMQ keeps the message until the consumer explicitly says,
   "I got it, you can delete it!"

4.Two types:
      Manual ACK: Consumer manually sends acknowledgment (auto_ack=False).
      Auto ACK: RabbitMQ automatically deletes message after sending (auto_ack=True).

5.Example (Python):
     channel.basic_consume(queue='test', on_message_callback=callback, auto_ack=False)
     Manual ack requires ->Inside callback:
               ch.basic_ack(delivery_tag=method.delivery_tag) -> ensures that ack is true i.e message is received while calling this function.
     Auto ack not require this.

6.If consumer fails before sending ACK â†’ RabbitMQ requeues the message for another consumer.
7.In short: ACK ensures message reliability & prevents data loss.


----------------- Exclusive Queue â€” Summary ---------------------

1. exclusive queue can be used by only one connection (one consumer) at a time.
2.When that connection closes, the queue is automatically deleted.
3.Itâ€™s created by setting:
   channel.queue_declare(queue='myq', exclusive=True)

4.Purpose: Used for temporary, private communication (like reply queues or single-client tasks).
5.Features:
    Auto-deletes when connection closes
    Cannot be shared by multiple consumers
    Good for one-time or short-lived tasks

6.Example use case: RPC-style communication â€” where one consumer gets a response to its request.
7.In short: Exclusive Queue = â€œPrivate queue for one connection â€” auto-deleted when done.â€


------------------------- Main Components of RabbitMQ ---------------------------

1.Producer â†’ Sends the message.
ğŸ”¹ Acts as the sender or data generator in the system.

2.Exchange â†’ Receives messages from the producer and routes them.
ğŸ”¹ Works like a post office, deciding where each message should go.

3.Queue â†’ Stores the messages temporarily.
ğŸ”¹ Acts like a mailbox where messages wait until a consumer picks them.

4.Binding â†’ Connects an exchange to a queue.
ğŸ”¹ Defines the routing rule (how messages are matched and delivered).

5.Consumer â†’ Receives and processes messages from the queue.
ğŸ”¹ Works as the receiver or worker that performs the required task.
